---
title: "Night Time Lights Analysis of New York City 2012 - 2022"
author: "Max Lutz, Liam Tobin, Mitchell Lazarz"
date: "5/4/2022"
vignette: >
  %\VignetteIndexEntry{floodlightblm_final}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The following packages are needed for our analysis.
```{r, eval = FALSE}
library(USF)
library(here)
library(geojsonsf) 
library(sp)
library(sf)
library(terra) 
library(raster)
library(exactextractr) 
library(dplyr)
library(tidyr)
library(zoo)
library(classInt)
library(ggplot2)
library(RColorBrewer) # Use for color palettes
library(viridis) # Use for color palettes
library(kableExtra) # Use for data table formatting
```

## Data

#### **1.  NYC Feature Datasets**

Public Housing Development data was acquired from [NYC Open Data](https://data.cityofnewyork.us/Housing-Development/NYCHA-GIS-file/tqnb-xmxw). This polygon dataset is a .geojson of all New York City Housing Authority developments. Additionally, census tracts and building foothills shapefiles are acquired from the same source. Census tract population data was acquired in tabular format from [NYC Planning Population FactFinder](https://popfactfinder.planning.nyc.gov/). The plot below shows the locations of public housing in blue and the Polo Grounds Towers circled in red overlaid on census tracts.

```{r, eval = FALSE}
# load shapefiles. Project to 2263
data("nytract")
nytract <- nytract 
st_transform(nytract, crs = 2263)

# Geojson of NYC public housing developments
data("nycha")
nycha <- nycha %>%
  st_transform(., crs = 2263)

# Select Polo Grounds Towers for proof of concept
polo <- nycha %>% dplyr::filter(., developmen == "POLO GROUNDS TOWERS") %>%
  st_transform(., crs = 2263)

# Import population data with common attribute to shapefile, "BoroCT2020"
data("ny_pop")
ny_pop <- ny_pop 

# Shapefile of NYC building footprints - source NYC open data
buildings <- geojson_sf("~/Clark/RA-ing/SummerInstitute/nightlight/data/Building_Footprints.geojson") %>%
     st_transform(., crs = 2263)

# BLM protests
blm_csv <- read.csv(here("~/Clark/RA-ing/SummerInstitute/nightlight/data/blmprotestpts.csv"))
blm_pts_night <- st_as_sf(blm_csv, coords = c("Long", "Lat"), 
                    crs = 4326) %>% st_transform(., crs = 2263)

# BLM protests at night
data("blm_csv_night")
blm_csv_night <- blm_csv_night
blm_pts_night_night <- st_as_sf(blm_csv_night, coords = c("Long", "Lat"), 
                          crs = 4326) %>% st_transform(., crs = 2263)
```

```{r, eval = FALSE}
#Display tracts with public housing in blue, and Polo Grounds in red with circle hightlighting the area
#install.packages("farver")
ggplot() +
  geom_sf(data = nytract, col = alpha("grey9", 0.1), fill = "grey") +
  geom_sf(data = nycha, aes(fill = 'A'), col = "blue4", 
          show.legend = "polygon", inherit.aes = F) +
  geom_sf(data = polo, aes(fill = 'B'), col = NA,
          show.legend = "polygon", inherit.aes = F) +
  geom_sf(data = polo %>% st_geometry() %>% st_centroid() %>% st_buffer(2000), 
          fill = NA, col = 'red4', 
          show.legend = F, inherit.aes = F) +
  ggtitle("NYC Public Housing Developments") +
  scale_fill_manual(values = c("A" = "blue", "B" = "red"), 
                    labels = c("Public Housing Developments", 
                               "Polo Grounds Towers")) +
  xlab('') + ylab('') +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.22, 0.92)) 
 # ggsave("C:/CLARK/GEOSPAAR/floodlightblm/ph_overview2.png")
```


#### **  NASA Black Marble Night Time Lights**

```{r, eval = FALSE}
# # List of .h5 files
# files <- list.files("E://blackmarble", pattern = ".h5", full.names = TRUE)
# 
# # Get dates from file names create vector to add to raster stack
# dates <- as.Date(sapply(files, function(x) {substr(x, 26, 32)}), format = "%Y%j")
# 
# # Create a list of processed images
# l <- lapply(files, function(i){
#   # Date character
#   d <- substr(i, 26, 32)
#   # Convert .h5 to SpatRaster
#   i_sr <- rast(i)
#   # Select gap-filled band and convert to raster
#   i_rast <- raster(i_sr[[3]])
#   # Set extent
#   extent(i_rast) <- c(-80, -70, 40, 50)
#   # Set crs
#   crs(i_rast) <- "EPSG:4326"
#   # Crop to NYC
#   i_rast_nyc <- crop(i_rast, c(-74.256, -73.699, 40.496, 40.916))
#   # Set NA
#   i_rast_nyc[i_rast_nyc == 65535] <- NA
#   # Rename with date
#   names(i_rast_nyc) <- d
#   return(i_rast_nyc)
# })
# 
# # Stack list of raster layers and add date
# s <- setZ(stack(l), dates, "date")
# 
# # Export raster stack
# writeRaster(s, "C://CLARK//GEOSPAAR//floodlightblm//data//bm_nyc_cen.grd",
#             format = "raster")
```

The following is a masked visualization of the mean NYC nighttime lights from 2012 to 2022.

```{r, eval = FALSE}
#install.packages("rgdal")
library(rgdal)
# Upload raster stack of nighttime lights
bm_nyc_cen <- stack("~/Clark/RA-ing/SummerInstitute/nightlight/data/bm_nyc_cen.grd")

s <- stack(bm_nyc_cen)

plot(s[[1]])
mean_s <- calc(s, mean, na.rm = TRUE)
# mean_s <- s_mean
# rm(s_mean)
plot(mean_s)

# Calculate the long term mean of nighttime lights, 
# project to NYC crs, then mask to NYC.

mean_sc <- mask(mean_s, st_transform(nytract, st_crs(mean_s)))


plot(mean_sc)

# Convert raster to dataframe for plotting
mean_s_df <- as.data.frame(rasterToPoints(mean_sc))
colnames(mean_s_df) <- c('x', 'y', 'value')

# Plot long term mean of nighttime lights for NYC
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = mean_s_df) +
  ggtitle("NYC Nighttime Lights mean radiance 2012 - 2022") +
  scale_fill_viridis(guide = guide_colorbar(title = "nWatts·cm−2·sr−1", 
                                             ticks = FALSE)) +
  xlab('') + ylab('') +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.2, 0.8)) 
 # ggsave("C:/CLARK/GEOSPAAR/floodlightblm/mean_lights.png")
```

## Methods


#### **1.  Polo Grounds Towers Proof of Concept**

For this first part of the analysis, the goal was to be able to see if we could detect a known light installation in the New York Housing Authority project Polo Grounds. We found an article published on the nyc.gov website which claimed an installation of 341 new light fixtures at this location occurred between early August 2015 and March 10th, 2016. We first set out to see if we could find an anomaly in the amount of radiance from before and after the light installation. Then we set out to see how the values change over time to see if there are any recurring patterns by doing a rolling 30-day mean due to a large amount of noise in the data. Lastly, in an attempt to dampen the influence of yearly trends, we expanded the mean to quarterly.

```{r, eval = FALSE}
#Names of each layer aka dates in format Xyyyyjjj
 names_s <- names(s)
# taking out the X in the dates
dates_yj <- as.data.frame(names_s) %>%  lapply(., function(x) {
  gsub("X", "", x)})
#converting from yyyyjjj to date data format
dates <- lapply(dates_yj, function(x) {
  as.Date(x, format = "%Y%j")
})
#adding dates as z value to each layer
p <- as.data.frame(dates)
s2 <- setZ(s, p[,1], "date")
dates <- getZ(s2)
class(getZ(s2)) 
print(s2)
#Query Formatting
instal_sub <- subset(s2, 
                     which(getZ(s2) >= '2015-7-01' & (getZ(s2) <= '2016-03-10')))
plot(instal_sub)

#Getting subsets of before and after year of known installation 
before_inst_sub <- subset(s2, 
                          which(getZ(s2) <= '2015-07-01' & 
                                  (getZ(s2) >= '2014-07-01')))
plot(before_inst_sub)
after_inst_sub <- subset(s2, 
                         which(getZ(s2) >= '2016-03-10' & 
                                 (getZ(s2) <= '2017-03-10')))
plot(after_inst_sub)
#Creating one year means before and after the installation of lights at Polo Grounds

before_mean <- calc(before_inst_sub, mean, na.rm = TRUE)
plot(before_mean)

after_mean <- calc(after_inst_sub, mean, na.rm = TRUE)
plot(after_mean)


#Plots of before and after means 
ba_mean_s <- stack(before_mean, after_mean)
names(ba_mean_s) <- c("Aug_2014-2015", "Aug_2016-2017")
plot(ba_mean_s)

#Annomalies of irradnace, from before and after light installation
diff <- (after_mean - before_mean)
plot(diff)

#Histogram of the difference, where positive values indicate increase in values and negative indicates decrease in values
par(mar = c(3, 3, 3, 3))
hist(diff, col = "blue", xlab = "iradiance", breaks = 12)

#cropping the anamoly for Polo Grounds, turns out only 1 pixel
rpolo_ann <- crop(x = diff, y = st_transform(polo, st_crs(diff)))
plot(rpolo_ann)
```

```{r}
#subsetting on a ~3 year time frame of before during and after light installation to see if one can find anomalies 

polo <- polo %>% st_transform(., crs = 4326)

sub1 <- subset(s2, which(getZ(s2) >= '2014-07-01' & (getZ(s2) <= '2017-06-30')))
polo_s <- crop(x = sub1, y = st_transform(polo, st_crs(sub1)))
st_bbox(polo_s)
st_bbox(polo)
plot(polo_s[[5]])
plot(polo$geometry, add = TRUE)

polo_frame <- raster::extract(
  x = polo_s, 
  y = st_transform(polo, st_crs(polo_s)), small = TRUE, 
  na.rm = TRUE) %>% unlist(.) %>% as.data.frame(.) #%>% 
 # mutate(., date = getZ(sub1)) # this line doesn't work

bb <- st_bbox(st_transform(polo, st_crs(polo_s)))
plot(polo_s[[5]], xlim = bb[c(1, 3)], ylim = bb[c(2, 4)])
bb
st_transform(polo, st_crs(polo_s))


polo_roll <- polo_frame %>% mutate(month_av = rollapply(polo[[1]], 
              width = 30, FUN = function(x) mean(x, na.rm = TRUE), fill = NA))
# Creation of 30 day rolling mean of 3 year chunk analyzed above to display why a decrease in radiance is seen
polo_roll %>% 
ggplot() + 
  geom_line(mapping = aes(x = date, y = month_av), size = 1.2, col = "blue") +
  geom_line(polo_roll[(361:614),], mapping = aes(x = date, y = month_av), 
            size = 1.2, col = "red") +
  xlab("Date") + ylab("Radiancen (Watts·cm^−2·sr^−1)") +
  ggtitle("Polo Grounds 30 day rolling mean with light installation period highlighted in red") 
 # ggsave("C:/GEOG246_R/floodlightblm/vignettes/graphics/rolling_mean_window2.png")
```


Seeing Polo Grounds in the context of the whole time series by doing a 30 day rolling mean.

```{r}
# Cropping the time series to Polo Grounds
polo_s2 <- crop(x = s2, y = polo) # error no non-missing arguments to min
# Making a data frame from those radiance values form all the layers
polo_frame_full_full <- raster::extract(x = polo_s2,
                   y = polo, exact = TRUE, na.rm = TRUE) %>% unlist(.) %>% 
                  as.data.frame(.) %>% mutate(., date = getZ(s2))
# Executing a rolling mean of 30 days across the whole time series and saving it as a new column in the data frame.
polo_roll_full <- polo_frame_full_full %>%
  mutate(month_av = rollapply(polo_frame_full_full[[1]],
                width = 30, FUN = function(x) mean(x, na.rm = TRUE), fill = NA))
# NA values are excluded from this rolling mean and the first 15 are NA.
polo_roll_full %>% 
ggplot() + geom_line(mapping = aes(x = date, y = month_av), col = "blue", size = 1.2) +
  geom_line(polo_roll_full[(1244:1497), ], 
            mapping = aes(x = date, y = month_av), col = "red", size = 1.2) +
  ggtitle("Rolling 30 day mean over Polo Grounds with light installation period highlighted in red") +
  ylab("Radaice (Watts·cm^−2·sr^−1)") + xlab(NULL) 
  
  #ggsave("C:/GEOG246_R/floodlightblm/vignettes/graphics/rolling_mean_polo.png")
```


Looking at quarterly means to smooth over short term trends.
```{r, out.width = "60%", echo = FALSE, fig.align = 'center'}
# Summarizing the radiance values over Polo Grounds by 3-month means in an effort
# to lessen the influence of the February spike in radiance seen every year. 
zoo_frame <- polo_roll_full %>% 
  mutate(quarter = as.yearqtr(polo_roll_full$date, format = "%Y-%m-%d")) %>%
  mutate(radiance = as.numeric(polo_roll_full$.)) %>% 
  group_by(quarter) %>% 
  summarise(., mean = mean(radiance, na.rm = TRUE)) %>% 
  as.data.frame(.) %>% 
  mutate(year = as.yearqtr(.$quarter, format = "%y/0%q") %>%
  format(., format = "%y")) %>%
  mutate(row_num = seq.int(nrow(.))) %>% 
  mutate(group = ifelse(row_num < 15, "Before", 
                        ifelse(row_num > 17, "After", "During")))
# Looking at the difference of before and after installation with full time scale
zoo_table <- zoo_frame %>% 
  group_by(group) %>% 
  summarise(., mean = round(mean(mean))) %>% 
  as.data.frame(.) 
# Adding the difference row in the table
zoo_table[nrow(zoo_table) + 1, ] <- c("difference", 
                                      (zoo_table$mean[1] - zoo_table$mean[2]))
# Creation of a more visually appealing table
zoo_table %>% kable() %>% kable_styling() %>% 
  as_image(file = "C:/GEOG246_R/floodlightblm/vignettes/graphics/polo_table.png")
# Line plot of quarterly 
ggplot(zoo_frame) +
  geom_line(aes(x = quarter, y = mean), size = 0.5) + ylab("Radiance") +
  geom_point(mapping = aes(x = quarter, y = mean, color = group), size = 2) +
  xlab(NULL) +
  ggtitle("Comparison of radiance of before and after
light instalation at Polo Grounds by looking at quarterly means") 
  # ggsave("C:/GEOG246_R/floodlightblm/vignettes/graphics/polo_qline_plot.png")
```

Full time series mean split by time period with difference of before and after light installation.



#### **2.  BLM Protest Analysis**


Plotting all BLM Protest Points. 

```{r, error = TRUE, warning = FALSE, message = FALSE, fig.height = 6, fig.width = 6, fig.align = 'center', eval = FALSE}
# Visualize protest points
par(mar = c(0, 0, 1, 0))
plot(nytract %>% st_geometry(), col = "grey", pch = NA, border = "grey9", 
     main = "BLM Protest Locations")
plot(blm_pts_night %>% st_geometry(), col = "blue", pch = 16, add = TRUE)
```


Plotting long term mean of Nighttime lights with BLM Protest Points on top. 

```{r, error = TRUE, warning = FALSE, message = FALSE, fig.height = 6, eval = FALSE}
# Plot long term mean of nighttime lights for NYC with BLM Night Protest Points.
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = mean_s_df) +
  geom_sf(data = nytract, fill = NA, col = alpha("white", 0.2)) +
  geom_sf(data = blm_pts_night_night, fill = NA, col = "deeppink") + 
  ggtitle("Mean Radiance 2012 - 2022 with BLM Protest Points") +
  scale_fill_gradient(low = 'black', high = 'yellow',
                      guide = guide_colorbar(title = "", 
                                             ticks = FALSE)) +
  xlab('') + ylab('') +
  coord_sf(expand = 0) +
  theme_minimal() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank()) 
#  ggsave("external/nightlight/blm_points_mean_radiance.png")
```

Mean 3 day period - comparing it over multiple years. BLM Nighttime Protest Points Overlay 
Doing the same method for the BLM Protests that occurred at night. looking at a 3 month window, look only at the single pixel in which each protest happened, plot those values and highlight the night of the protest in red.

Using NASA black marble to evaluate mean nighttime lights and dates. 

```{r, eval = FALSE}
# Names of each layer aka dates in format Xyyyyjjj
 names_s <- names(s)
# taking out the X in the dates
dates_yj <- as.data.frame(names_s) %>%  lapply(., function(x) {
  gsub("X", "", x)})
# converting from yyyyjjj to date data format
dates <- lapply(dates_yj, function(x) {
  as.Date(x, format = "%Y%j")
})
# assigning data names to raster stack layers in z Value

p <- as.data.frame(dates)
s2 <- setZ(s, p[,1], "date")
dates <- getZ(s2)
class(getZ(s2)) 
print(s2)

# additional code
before_inst_sub <- subset(s2, which(getZ(s2) <= '2015-07-01' & (getZ(s2) >= '2014-07-01')))

```

Polo Ground Code / BLM Protest Point Work Space

Figuring out means for BLM Protest Areas using Polo Ground and NASA Black Marble data. 

```{r, eval = FALSE}
#Names of each layer 
 names_s <- names(s)

# taking out the X in the dates
dates_yj <- as.data.frame(names_s) %>%  lapply(., function(x) {
  gsub("X", "", x)})

#converting from yyyyjjj to date data format
dates <- lapply(dates_yj, function(x) {
  as.Date(x, format = "%Y%j")
})

#adding dates as z value to each layer
p <- as.data.frame(dates)
s2 <- setZ(s, p[,1], "date")
dates <- getZ(s2)
class(getZ(s2)) 
print(s2)

#Query Formatting
instal_sub <- subset(s2, 
                     which(getZ(s2) >= '2014-5-28' & (getZ(s2) <= '2021-06-01')))

#Getting subsets of before and after year of known installation 
blm_2020_sub <- subset(s2, 
                       which(getZ(s2) >= '2020-5-28' & (getZ(s2) <= '2020-06-01')))
blm_2019_sub <- subset(s2, 
                       which(getZ(s2) >= '2019-5-28' & (getZ(s2) <= '2019-06-01')))
blm_2018_sub <- subset(s2, 
                       which(getZ(s2) >= '2018-5-28' & (getZ(s2) <= '2018-06-01')))
blm_2017_sub <- subset(s2, 
                       which(getZ(s2) >= '2017-5-28' & (getZ(s2) <= '2017-06-01')))

#Creating one year means before and after the installation of lights at Polo Grounds
blm_2020_mean <- mean(blm_2020_sub, na.rm = TRUE)
blm_2019_mean <- mean(blm_2019_sub, na.rm = TRUE)
blm_2018_mean <- mean(blm_2018_sub, na.rm = TRUE)
blm_2017_mean <- mean(blm_2017_sub, na.rm = TRUE)

#Plots of before and after means 
blm_mean_s <- stack(blm_2020_mean, blm_2019_mean, blm_2019_mean, blm_2017_mean)
names(blm_mean_s) <- c("May_June_2020", "May_June_2019", "May_June_2018", "May_June_2017")
blm_mean_overtime <- plot(blm_mean_s)
# dev.copy(png, "external/nightlight/blm_mean_overtime.png")
# dev.off()

```

#### **3.  Public Housing Lights Analysis**

In this part of the analysis, the 10-year mean of nighttime lights is compared for pixels that have and do not have public housing.  The goal is to select pixels at the resolution of the nighttime lights image that represent presence of public housing.  Then pixels without public housing will be sampled if they have a similar structure as represented by population and building density. A fractional coverage raster is created where the proportion of 500 m pixel area covered by public housing is established.  All area calculations in this section are made using the NAD83 / New York Long Island (ft US) projected coordinate system (EPSG:2263).

```{r, eval = FALSE}

# Define raster with extent and resolution as mean nighttime lights
r <- mean_s
values(r) <- 1:ncell(r)

# Create raster with proportion of pixel covered by public housing
# ph_fraction <- coverage_fraction(r, st_combine(nycha))[[1]]

# Export raster
# writeRaster(ph_fraction, 
#             "C://CLARK//GEOSPAAR//floodlightblm//data//ph_coverage.grd", 
#             format = "raster")

# Assign 0 to NA then convert raster to dataframe for plotting
# ph_fraction[ph_fraction == 0] <- NA
# ph_frac_df <- as.data.frame(rasterToPoints(ph_fraction))
# colnames(ph_frac_df) <- c('x', 'y', 'value')



city_background <- pop_r
city_background[city_background >= 0] <- 0

ph_fraction <- coverage_fraction(r, st_combine(nycha))[[1]]
ph_fraction[is.na(ph_fraction)] <- 0

ph_fraction <- mask(ph_fraction, city_background)
# or
# ph_fraction <- ph_fraction * city_background
ph_frac_df <- as.data.frame(rasterToPoints(ph_fraction))
colnames(ph_frac_df) <- c('x', 'y', 'value')
ph_frac_df <- ph_frac_df %>% filter(!is.na(value)) 


# Plot fractional coverage image of public housing tracts
ggplot() + 
  geom_sf(data = nytract, col = "lightgrey", fill = NA) +
  geom_raster(aes(x = x, y = y, fill = value), data = ph_frac_df) +
  ggtitle("Proportion of pixel area with public housing") +
  scale_fill_viridis_b(breaks = seq(0, 0.8, 0.1), 
                     guide = guide_colorbar(title = "", 
                                            ticks = FALSE)) +
  xlab('') + ylab('') +
  coord_sf() +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.1, 0.85)) 
 # ggsave("external/nightlight/ph_plot.png")

```

The map below shows the area proportion of 500 m pixels covered with public housing developments

#### *Create gridded population from census tracts*

The next step is to create an areal interpolated population grid.  We want to know the approximate population within each 500 m night time lights grid cell.  This is done by intersecting census tracts with the 500 m resolution grid.  The area of census tracts segments is calculated, then divided by the original tract size to find the area proportion of the segment.  Then the population for the tract is multiplied by the area proportion of the segments to find the approximate population in each tract segment.  Lastly, the tract segment populations are summed within each 500 m grid cell. 

```{r, eval = FALSE}
## Create areal interpolated population grid

# Add area to census tracts then join population data
nytract_pop <- nytract %>% 
  mutate(area = as.numeric(st_area(.) / 10^6)) %>% 
  mutate(BoroCT2020 = as.numeric(BoroCT2020)) %>% 
  inner_join(., ny_pop, by = "BoroCT2020")

# Convert empty raster to polygons
grid_p <- rasterToPolygons(x = r, dissolve = FALSE) %>% st_as_sf()

# Intersect tracts with polygon grid and calculate area of segments
# then calculate population within each 'cutup' census tract piece
tracts_cut <- st_intersection(x = nytract_pop, y = grid_p) %>% 
  mutate(area_seg = as.numeric(st_area(.) / 10^6)) %>% 
  mutate(pop_seg = area_seg / area * Pop_20)


# Calculate sum of population of tract segments within each cell
# The 'layer' column indicates which cell index the tract segment belongs to
r_pop_vals <- tracts_cut %>% group_by(layer) %>% 
  summarise(., pop = sum(pop_seg, na.rm = TRUE))

# Find cell index for NA values
not_in_df <- data.frame(subset(1:ncell(r), !(1:ncell(r) %in% r_pop_vals$layer)), NA)
names(not_in_df) <- c("layer", "pop")

# Combine values for cells with and without population 
r_pop_vals_full <- rbind(not_in_df, r_pop_vals %>% 
                           as.data.frame() %>% 
                           select(., c("layer", "pop"))) %>% 
  mutate(., layer = as.numeric(layer)) %>% arrange(., layer)

# Create gridded population raster by setting the population column to the empty raster
r_pop <- setValues(r, values = r_pop_vals_full$pop)

# Convert population to integer
r_pop[] <- as.integer(r_pop[])

# # Export 2020 gridded population
# writeRaster(r_pop, 
#             "C://CLARK//GEOSPAAR//floodlightblm//data//pop2020_grid.grd", 
#             format = "raster")

# Tract Population map -- This is the true population
ggplot() +
  geom_sf(data = nytract_pop, aes(fill = Pop_20), col = NA) +
  ggtitle("Population by Census Tract") +
  scale_fill_gradient(low = 'lightsteelblue2', high = 'darkblue', 
                      guide = guide_colorbar(ticks = FALSE), 
                      limits = c(0, cellStats(r_pop, max)),
                      oob = scales::squish) +
  xlab('') + ylab('') + 
  labs(caption = paste("True Total Population = ",
                       as.character(sum(nytract_pop$Pop_20)))) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.title = element_blank(),
        legend.position = c(0.1, 0.85)) 
 # ggsave("external/nightlight/pop_plot1.png")
  
# Convert raster to dataframe for plotting
r_pop_df <- as.data.frame(rasterToPoints(r_pop))
colnames(r_pop_df) <- c('x', 'y', 'value')

# Interpolated Population map -- This is the output
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = r_pop_df) +
  ggtitle("Population Grid from areal interpolation") +
  scale_fill_gradient(low = 'lightsteelblue2', high = 'darkblue', 
                      guide = guide_colorbar(ticks = FALSE),
                      limits = c(0, cellStats(r_pop, max))) +
  labs(caption = paste("Interpolated Population = ", 
                       as.character(cellStats(x = r_pop, stat = "sum")))) +
  xlab('') + ylab('') +
  coord_sf() +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.title = element_blank(),
        legend.position = c(0.1, 0.85)) 
 # ggsave("external/nightlight/pop_plot2.png")
```

The maps below compare the true 2020 census tract population to the interpolated population grid.

#### *Create gridded building volume from NYC buildings*

The same process for creating a gridded population raster is used for creating a building volume grid.  First the volume of each building is determined by converting the building height attribute (height_roof) to meters.  Then, the area of each building (m^2) is determined and multiplied by building height to find the building volume.  An intersection is performed to find the building segments in each 500 m grid cell then the area of each building segment is calculated.  The area proportion of each building segment to the full building area is determined then multiplied by the full building volume.  The building volume of segments is summed within each grid cell to find the approximate total building volume within each night time lights pixel.

```{r, eval = FALSE}
## Create building volume grid

# Filter buildings that are fully constructed (feat_code 2100), 
#buildings_c <- buildings %>% filter(., feat_code == 2100)

# Convert building height to meters, calculate area, then calculate volume

buildings_vol <- buildings %>% 
  mutate(heightroof_1 = as.numeric(heightroof) / 3.281) %>% 
  mutate(area = as.numeric(units::set_units(st_area(.), "m^2"))) %>% 
  mutate(volume = area * heightroof_1)

# Intersect buildings with polygon grid and calculate area of segments
# then find proportional volume
build_cut <- st_intersection(x = st_transform(buildings_vol, st_crs(grid_p)), y = grid_p) %>% 
  mutate(area_seg = as.numeric(units::set_units(st_area(.), m^2))) %>% 
  mutate(volume_seg = area_seg / area * volume)



# Convert to dataframe selecting cell value (layer) and volume of segment
build_cut_df <- build_cut %>% as.data.frame(.) %>% select(., c('layer', 'volume_seg'))

# Find total building volume in each cell
r_bvol_vals <- build_cut_df %>% group_by(layer) %>% 
  summarise(., vol = sum(volume_seg, na.rm = TRUE))

# Find cell index for NA values
not_in_df <- data.frame(subset(1:ncell(r), 
                               !(1:ncell(r) %in% r_bvol_vals$layer)), NA)
names(not_in_df) <- c("layer", "vol")

# Combine values for cells with and without buildings 
r_vol_vals_full <- rbind(not_in_df, r_bvol_vals) %>% 
  mutate(., layer = as.numeric(layer)) %>% arrange(., layer)

# Create gridded building volume raster
r_bvol <- setValues(r, values = r_vol_vals_full$vol)
r_bvol[r_bvol == 0] <- NA

# Export building volume raster
# writeRaster(r_bvol, 
#             "C://CLARK//GEOSPAAR//floodlightblm//data//buildvol_grid.grd", 
#             format = "raster")

# Convert raster to dataframe for plotting, convert from cubic meters to cubic hectometers
r_bvol_df <- as.data.frame(rasterToPoints(r_bvol / 1000000))
colnames(r_bvol_df) <- c('x', 'y', 'value')

# Get 7 class breaks for visualization
breaks_qt <- classIntervals(
  c(min(r_bvol_df$value) - min(r_bvol_df$value), r_bvol_df$value), 
                            n = 7, style = "fisher")

# Add class breaks as column in the building volume dataframe
r_bvol_df <- mutate(r_bvol_df, value_qt = cut(value, breaks_qt$brks)) 

# Interpolated building volume map
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value_qt), data = r_bvol_df) +
  ggtitle("Building Volume Grid from areal interpolation") +
  scale_fill_brewer(palette = "OrRd")  +
  xlab('') + ylab('') + labs(fill = expression(hm^3)) +
  coord_sf() +
  theme_bw() +
  labs(caption = "0.75 hm^3 would be a pixel 100% covered with 1 story houses") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.15, 0.75)) 
 # ggsave("external/nightlight/bvol_plot.png")
```

The map below shows the areal interpolated volume of buildings in each 500 m cell.

#### *Sample pixels with and without public housing.*

The 10-year mean nighttime lights for pixels with public housing (PH) coverage is compared to those without public housing (NoPH). First, PH pixels are filtered so there is a minimum of 10% public housing area coverage. There are 179 pixels with at least 10% coverage. Next, the population and building volume for these pixels are extracted.  Then the quartile breaks for population and building volume in PH pixels is determined. A cross-tabulation table is created to find the frequency of PH pixels in these breaks. This frequency is used to perform a stratified sample on NoPH pixels. NoPH pixels are randomly sampled to meet the population and building volume conditions and frequencies so 179 NoPH pixels are selected. Radiance, building volume, and population are extracted for sampled NoPH pixels.

```{r, eval = FALSE}
# Upload Public Housing Fractional coverage raster
ph_r <- ph_fraction

# Upload gridded population
pop_r <- r_pop

# Upload gridded building volume, convert to cubic hectometers
bvol_r <- r_bvol / 1000000

# Find PH pixels with at least 10% coverage of tracts with public housing
ph_full_r <- ph_r > 0.1
ph_full_r[ph_full_r == 0] <- NA

# Mask gridded population with PH pixels
pop_ph <- pop_r * ph_full_r

# Quartile class breaks for population for PH pixels
pop_breaks_qt <- classIntervals(c(cellStats(pop_ph, min) - 1, getValues(pop_ph)), 
                            n = 4, style = "quantile")

# Mask gridded building volume
bvol_ph <- bvol_r * ph_full_r

# Quartile breaks for building volume with PH pixels
bv_breaks_qt <- classIntervals(
  c(cellStats(bvol_ph, min) - cellStats(bvol_ph, min), getValues(bvol_ph)), 
                            n = 4, style = "quantile")

# Convert PH pixels greater then 10% coverage to points
ph_p <- rasterToPoints(ph_full_r) %>% as.data.frame() %>% 
  st_as_sf(., coords = c("x", "y"))

# Create column that specifies that pixels contain public housing
# Extract radiance, population, and building volume
# Create columns with population and building volume class breaks
extract_ph_p <- ph_p %>% mutate(., sample = "PH") %>%
  mutate(., radiance = raster::extract(mean_s, .)) %>% 
  mutate(., population = raster::extract(pop_r, .)) %>% 
  mutate(., building_volume = raster::extract(bvol_r, .)) %>% 
  mutate(., pop_class = cut(population, pop_breaks_qt$brks, dig.lab = 4)) %>% 
  mutate(., bvol_class = cut(building_volume, bv_breaks_qt$brks, dig.lab = 2))

# Create a frequency cross tabulation of pixels within population and building 
# volume quartiles.
t <- table(pop = extract_ph_p$pop_class, bvol = extract_ph_p$bvol_class)

# Reformat frequency cross tabulation to a dataframe in order to for query
# and stratified sampling of No PH pixels
t2 <- as.data.frame(t) %>% 
  separate(., col = pop, into = c("pop_l", "pop_u"), sep = ",") %>% 
  separate(., col = bvol, into = c("bvol_l", "bvol_u"), sep = ",") %>% 
  mutate(., pop_l = as.numeric(gsub("\\(", "", pop_l))) %>% 
  mutate(., pop_u = as.numeric(gsub("\\]", "", pop_u))) %>%
  mutate(., bvol_l = as.numeric(gsub("\\(", "", bvol_l))) %>% 
  mutate(., bvol_u = as.numeric(gsub("\\]", "", bvol_u))) %>% 
  filter(., Freq > 0)

# Find pixels with at 0% coverage with public housing
no_ph_r <- ph_r == 0

plot(no_ph_r)

# This lapply masks the NYC extent based on the population class and building volume
# class criteria.  The number of pixels randomly sampled from the No PH raster is the 
# same number in the frequency cross tabulation.  This is done to ensure that the sampled
# No PH pixels represent the same population and building volume conditions as the PH pixels.
set.seed(19)
no_ph <- lapply(1:nrow(t2), function(i) { 
  x <- t2[i, ]
  pop_mask <- pop_r > x$pop_l & pop_r <= x$pop_u
  bvol_mask <- bvol_r > x$bvol_l & bvol_r <= x$bvol_u
  no_ph_r_masked <- no_ph_r * pop_mask * bvol_mask
  no_ph_r_masked[no_ph_r_masked == 0] <- NA
  no_ph_smp <- sampleRandom(x = no_ph_r_masked, size = x$Freq, cells = TRUE)
  return(no_ph_smp[, 1])}) %>% unlist()
# Bind cell index with a column 'layer' set to 1, indicating sampled
no_ph_df <- cbind(cell = no_ph, layer = rep(1, length(no_ph)))

# Find cell index for non sampled pixels and set 'layer' to NA
not_in_df <- data.frame(subset(1:ncell(r), !(1:ncell(r) %in% no_ph)), NA)
names(not_in_df) <- c("cell", "layer")

# Combine values for non-sample and samples
r_smp_df <- rbind(not_in_df, no_ph_df) %>% arrange(., cell)

# Create a raster where No PH sampled pixels are 1, and non sampled pixels are NA
r_smp <- setValues(r, values = r_smp_df$layer)

# Convert No PH sample raster to points
smp_p <- rasterToPoints(r_smp) %>% as.data.frame() %>% 
  st_as_sf(., coords = c("x", "y"), crs = st_crs(mean_s))

# Create column that specifies that pixels do not contain public housing
# Extract radiance, population, and building volume
# Create columns with population and building volume class breaks
extract_noph_p <- smp_p %>% mutate(., sample = "No PH") %>% 
  mutate(., radiance = raster::extract(mean_s, .)) %>% 
  mutate(., population = raster::extract(pop_r, .)) %>% 
  mutate(., building_volume = raster::extract(bvol_r, .)) %>% 
  mutate(., pop_class = cut(population, pop_breaks_qt$brks, dig.lab = 4)) %>% 
  mutate(., bvol_class = cut(building_volume, bv_breaks_qt$brks, dig.lab = 2))

# Combine ph and no ph samples
combined <- rbind(as.data.frame(extract_noph_p), 
                  as.data.frame(extract_ph_p))

# Display map of PH and No PH samples 
ggplot() + 
  geom_sf(data = nytract, col = "lightgrey", fill = NA) +
  geom_sf(data = combined %>% st_as_sf(), aes(fill = sample, col = sample)) +
  ggtitle("Locations of Samples") +
  scale_color_manual(values = c("red", "blue")) +
  xlab('') + ylab('') +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.1, 0.9),
        legend.title= element_blank()) 
#ggsave("external/nightlight/samples_map0.png", 
#         width = 6, height = 6)
```

Below shows the locations of pixels with at least 10% area coverage of public housing and sampled pixels without public houses with the same building and population structure.

## Results

When analyzing the results of our project it is crucial to understand our emphasis on spatial visualization. Our figures consist of BLM nighttime protest locations with a mean floodlight analysis before and after. Moreover, the distribution of long term means nighttime lights of NYC, and the same nighttime floodlight analysis but with the Polo Ground Towers. To truly understand these visuals, we had to implement an appropriate scale bar, title, legend, and filter upon each individual map. With the restrictions of our data, the Polo Ground Towers analysis only contained one pixel. Although limiting, we were able to construct an accurate visual analysis of this pixel through both a manual time series and vectorized distribution. Coupled with this, our final public housing analysis used a variety of tools in its result. Our culminating visuals were a raster with a proportion of pixels covered by census tracts with public housing. Furthermore, the creation of a building volume grid in which an interpolated population map was added. This analysis also contained a long term mean radiance for public housing, population, and building volume. 

#### **1.  Polo Grounds Towers Proof of Concept**

Looking at the original anomaly analysis of comparing the mean radiance from the year prior to the year after the light installation at Polo Grounds, we found there to be a decrease of 190 (Watts·cm^−2·sr^−1) over the housing site. Meaning we were unable to detect any increase in radiance due to the installation of new light fixtures using the method above. Furthermore, when expanding the time frame of the analysis from 2014-2016 to 2012-2022, we still saw an overall decrease of the radiance by 36 when comparing the time period before and after the light installation. This can be visually seen in the boxplot below, keep in mind not all boxes have equal amounts of observations.

# zoo_frame doesn't work.

```{r, eval = FALSE}
#Using the same data frame of the quarterly means used in the line plot in section 1 of methods.
# ggplot(zoo_frame) + 
#   geom_boxplot(aes(x = group, y = mean, fill = group)) +
#   ylab("Radiance") + xlab(NULL) +
#   ggtitle("Comparison of radiance of before and after light instalation at Polo Grounds") 
#   ggsave("C:/GEOG246_R/floodlightblm/vignettes/graphics//polo_boxplot.png")
```


```{r, echo = FALSE, out.width = "80%", fig.align = 'center'}
#knitr::include_graphics("graphics\\polo_boxplot.png")
```


#### **2.  BLM Protest Analysis**

Analyzing the locations of BLM Protest Point centroids with nighttime mean radiance data from 2012 - 2022 allows for a unique perspective of social politics within New York City. Within this visual we can see the development of nighttime hot spots over time, as well, as the lighting factors that took place before the BLM Protests. 

```{r, eval = FALSE}
ggplot() + 
  geom_raster(aes(x = x, y = y, fill = value), data = mean_s_df) +
  geom_sf(data = nytract, fill = NA, col = alpha("white", 0.2)) +
  geom_sf(data = blm_pts_night_night, fill = NA, col = "deeppink") + 
  ggsave("BLM_Points_Mean_Radiance.png")
  scale_fill_gradient(low = 'black', high = 'yellow',
                      guide = guide_colorbar(title = "", 
                                             ticks = FALSE)) +
  xlab('') + ylab('') +
  coord_sf(expand = 0) +
  theme_minimal() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text.y = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks = element_blank())
 # ggsave("C:/GEOG246_R/floodlightblm/vignettes/graphics/blm_points_mean_radiance.png")
```

```{r, out.width = "60%", echo = FALSE, fig.align = 'center'}
#knitr::include_graphics("graphics\\blm_points_mean_radiance.png")
```

When analyzing the mean nighttime floodlight radiance across the 3-day window of BLM locations May into June (2017 - 2020). There is an obvious increase in mean radiance within 2020. However, there are only a few BLM Protest points that reside within these locations. Upon the conclusion of these results it is important to understand the correlation between BLM Protests and floodlight use are minimal. Although the potential of floodlight usage may increase with the presence of police officers at these protests, there are many factors at play when analyzing light radiation. 

```{r, eval = FALSE}
blm_mean_s <- stack(blm_2020_mean, blm_2019_mean, blm_2019_mean, blm_2017_mean)
names(blm_mean_s) <- c("May_June_2020", "May_June_2019", "May_June_2018", "May_June_2017")
blm_mean_overtime <- plot(blm_mean_s)
#dev.copy(png, "blm_mean_overtime.png")
#dev.off()
```

```{r, out.width = "60%", echo = FALSE, fig.align = 'center'}
#knitr::include_graphics("graphics\\blm_mean_overtime.png")
```

#### **3.  Public Housing Lights Analysis**

Two boxplots were created with the 10-year mean night time lights on the y-axis and either the Population class or Building Volume class on the x-axis.  Within each class, the distribution of pixels with and without public housing developments are compared.  In each boxplot, there are 44 to 45 pixels represented in the distribution. 

```{r, eval = FALSE}
# Create boxplot comparing mean radiance for public housing vs none within population classes
ggplot(combined, aes(x = pop_class, y = radiance, color = sample, fill = sample)) +
  scale_color_manual(values = c('red', 'blue')) +
  scale_fill_manual(values = alpha(c('red', 'blue'), 0.3)) +
  xlab("Population Class") + ylab("10 year mean radiance") +
  stat_summary(geom = "point", fun = mean, pch = 4, 
               position = position_dodge(.75)) +
  geom_boxplot() +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_blank())
  # ggsave("external/nightlight/boxplot1.png", 
  #        width = 9, height = 6)
```

```{r, out.width = "80%", echo = FALSE, fig.align = 'center'}
#knitr::include_graphics("graphics\\boxplot1.png")
```

The above boxplot displaying the Population class on the x-axis shows that in both pixels with and without public housing, the 10-year mean radiance increases with population.  Both the mean (indicated by an X) and median (indicated by the line), increase when moving from lower to higher population classes.  Within each Population class, we see that both the mean and median radiance value is greater for pixels with public housing.  In the three largest Population classes, the interquartile ranges for the public housing pixels are outside and greater than the interquartile ranges of those without public housing, while there is a slight overlap in the lowest class.  In all plots, values greater than the 75th percentile in the NOPH distributions overlap the interquartile range of the PH distributions.  

```{r, eval = FALSE}
# Create boxplot comparing mean radiance for public housing vs none within building volume classes
ggplot(combined, aes(x = bvol_class, y = radiance, color = sample, fill = sample)) +
  scale_color_manual(values = c('red', 'blue')) +
  scale_fill_manual(values = alpha(c('red', 'blue'), 0.3)) +
  xlab("Building Volume Class") + ylab("10 year mean radiance") +
  stat_summary(geom = "point", fun = mean, pch = 4, 
               position = position_dodge(.75)) +
  geom_boxplot() +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_blank()) 
  # ggsave("external/nightlight/boxplot2.png", 
  #        width = 9, height = 6)
```

```{r, out.width = "80%", echo = FALSE, fig.align = 'center'}
#knitr::include_graphics("graphics\\boxplot2.png")
```

In the above boxplot displaying the Building Volume class on the x-axis, similar trends are found.  Both the mean and median values, increase when moving from lower to higher Building Volume classes.  Within each Building Volume class, both the mean and median radiance value is greater for pixels with public housing.  In the three largest Population classes, the interquartile ranges for the public housing pixels are outside and greater than the interquartile ranges of those without public housing, while there is a slight overlap in the lowest class.  In all plots, values greater than the 75th percentile in the NoPH distributions overlap the interquartile range of the PH distributions. 

## Discussion

There could be a multitude of reasons why we didn't detect the light installation at Polo Grounds in Part 1. First of all, we made many assumptions and worked with little information. For example, the article we used does not specify when the lights were installed, leading to the installation date to be between when they said it started in August 2015 and the publication date of the article, March 10th ~ 7 months. Secondly, we don't know what kinds of lights were installed nor where. Ideally, we would have floodlights at a known location for a known duration for the best proof of concept. 

During the analysis for part 1, we noticed a yearly pattern of large increases in nighttime radiance values during February every year, with the signal in some years much stronger than in others. It is unclear what this may be caused by, thoughts have included snow cover which is our leading thought, while other explanations have included satellite viewing angles which can alter what kinds of light sources the satellite can see, but getting that exact information would be extremely difficult. Additionally, no large festivals are seemly occurring at that time, and the pattern persists with the surrounding 9x9 pixels, leading us to think that this phenomenon should be investigated further. 

As seen in Part 3, there is a clear trend that areas with public housing have higher 10-year mean night time lights values than those without. Additionally, there appears to be a trend that increased Population and Building Volume contributes to increased night time lights.  By using a stratified sample to select pixels without public housing that have a similar population and building volume structure, we can see claim that there is a correlation with more confidence.  However, because the population and building class ranges are somewhat broad, we cannot precisely sample No PH pixels with the exact same structure. If this was done, the sample size would have been much smaller and the results may have been differed. 

Pixels that were used to define presence of public housing were those where the area proportion of the pixel covered by public housing was at least 10%. 10% coverage is equal to at least 25,000 m^2 of public housing building area within the pixel. We did not have data on the number of residents in these buildings so rather simply substantial presence of public housing was used.  Because of the coarse spatial resolution of this product, features besides public housing development could lead to the differences seen.

The cause of this difference in nighttime lights with and without public housing may not be due to installation of floodlights as the Polo Grounds proof of concept did not detect the installation of over 300 new streetlamps.  This difference may be due to public housing developments being constructed near industry or expressways. Pixels classified as having public housing could also contain these features that emit high amounts of light. Another reason may be that pixels with public housing developments may have lower tree cover than areas with similar population and building density.  Tree cover would mask light emitted from street lamps and shorter buildings.  

## Conclusion

The NASA Black Marble night time lights product may not be effective in detecting fine-scale spatial and temporal scale differences between images due to its coarse resolution, sensitivity to sensor angle, and patchy coverage due to cloud cover.  By temporally aggregating to a broader resolution, the sensor angle and coverage issues can be solved; however, we found that detecting floodlight installations finer than the 500 m resolution may not be possible.  Other features contained in the pixel of interest may be saturating or blocking the radiance values.  This product appears to be useful when looking at broader geographic trends, like comparing the 10-year mean radiance of different areas.  We found that nighttime lights for pixels containing public housing tend to be greater than pixels without public housing when controlling for Population and Building Volume within the pixel.  Although this trend may not be due to installation of police surveillance floodlights, it may show a difference in light pollution caused the infrastructure, industry, and lack of tree cover adjacent to public housing developments.

When looking at these results as a whole there is much to be improved upon in terms of future research. As previously mentioned, our choice of New York City was based upon a limitation of floodlight data due to cloud coverage and seasonal gaps in data observation. To further build upon the study of BLM protests, public housing trends, and growth in floodlight use surrounding housing blocks we must expand across the United States. In collecting data from multiple cities across the U.S or even the world one can begin to understand the influence of increased floodlights and new age policing in a nuanced way. Through just focusing on New York City, we were getting a very small handful of policing and crime data. Coupled with this, the Polo Ground Towers, although the only site with an accurate timeline, could be built upon with locations that contain more pixels. Overall, we were not expecting this many difficulties in terms of data collection in the project. The overall VIIRS floodlight location data was only accessible through NASA’s black marble database, and the BLM data was nearly nonexistent - or was entered without credible sources.  In future projects we would also like to create higher resolution images, as well as find a concrete proof of concept. 
